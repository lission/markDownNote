[TOC]

# 树

## 树形结构查询效率高于线性的原因

以二叉树为例，层数实际上是以2为底的对数，n叉树是以n为底的对树，所以查询效率是log(n)，即只需要查找层数次就可以找到元素。而线性遍历在找到元素之前要遍历每一个节点，时间复杂度O(N)。

[参考文档](https://www.pdai.tech/md/algorithm/alg-basic-tree.html#%E7%BA%A2%E9%BB%91%E6%A0%91)

## 二叉查找树(BST)

Binary Search Tree，指一棵空树或具有某些性质的树：

- 若任意节点左子树不为空，则左子树上所有节点的值均小于它的根节点的值
- 若任意节点右子树不为空，则右子树上所有节点的值均大于它的根节点的值
- 任意节点的左、右子树也分别为二叉查找树
- 没有键值相等的节点

二叉查找树查找、插入时间复杂度为O(logn)



## 平衡二叉树(AVL)

具备二叉查找树特性，同时根节点左右子数深度之差绝对值不超过1。其左右子树也是平衡二叉树。



## 红黑树(R-B Tree)

自平衡的二叉查找树，性质：

- 根节点是黑色的
- 每个叶子节点（指树尾端Nil指针或Null节点）都是黑色
- 节点只有红黑两色
- 根节点到任一叶子节点的路径上黑色节点是平衡的(黑平衡)
- 红色节点的两个子节点一定是黑色。

![img](https://github.com/lission/markdownPics/blob/main/data/red-balck-elementsname.png?raw=true)

插入数据时插入的节点是红色(保证黑平衡)。

[红黑树插入自平衡](https://www.geeksforgeeks.org/red-black-tree-set-2-insert/)

[红黑树删除自平衡](https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/)

红黑树的自平衡依靠左旋、右旋和变色来保证。

- 如果插入节点的父节点是黑色，无需调整；

- 如果插入节点的父节点是红色，分三种情况：

  - 叔叔节点存在，且为红色，将父节点和叔叔节点置为黑色。祖父节点即为根节点，直接染为黑色即可。如果祖父节点非根节点，此时需要将当前节点指向祖父节点，对祖父节点进行进一步的调整，当前插入节点为红色

  ![img](https://github.com/lission/markdownPics/blob/main/data/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%E4%B8%BA%E7%BA%A2%E8%89%B2.png?raw=true)

  - 叔叔节点不存在或为黑色，父节点是祖父节点左子节点

    - 将新节点调整为父节点的左孩子节点

      1. 将父节点作为新节点。

      2. 对新节点进行左旋。

    - 将父节点染为黑色。

    - 将祖父节点染为红色。

    - 对祖父节点进行右旋。

  - 叔叔节点不存在或未黑色，父节点是祖父节点右子节点

    - 将新节点调整为父节点的右孩子节点
      1. 将父节点作为新节点
      2. 对新节点进行右旋
    - 将父节点染为黑色。
    - 将祖父节点染为红色。
    - 对祖父节点进行左旋。 

![img](https://github.com/lission/markdownPics/blob/main/data/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%E4%B8%BA%E9%BB%91%E8%89%B2.png?raw=true)



## B树

B-Tree，是一种自平衡的m阶树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除，都在对数时间内完成。

B树适用于读写相对大的数据块的存储系统，如磁盘。

- 根节点至少有两个子女
- 每个中间节点都包含k-1个元素和k个孩子，其中m/2 <= k <= m
- 每个叶子节点都包含k-1个元素，其中m/2 <= k <= m
- 所有叶子结点都位于同一层
- 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分。

B-Tree中每个节点根据实际情况可以包含大量关键字信息和分支，如下为3阶B-Tree

![img](https://github.com/lission/markdownPics/blob/main/data/alg-tree-15.png?raw=true)



## B+树

B+树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+树特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，与二叉树起好相反。

在B树基础上，为叶子节点增加链表指针（B树+叶子有序链表），所有关键字都在叶子节点上，非叶子节点作为叶子节点的索引，B+树总是到叶子节点上才能命中。

**B+树的非叶子节点不保存数据，只保存子树的临界值（最大或最小），所以同样大小的节点，B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**。

B+树的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:

![img](https://github.com/lission/markdownPics/blob/main/data/alg-tree-16.png?raw=true)



## 总结

`数组`的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的

`普通链表`由于它的结构特点被证明根本不适合进行查找

`哈希表`是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找

`二叉查找树`因为可能退化成链表，同样不适合进行查找

`AVL树`是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦

`红黑树`是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树

`B树`与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引

`B+树`在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中