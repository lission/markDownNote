06.27~07.01

[TOC]

# Algorithm

## leetcode#206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

迭代法

```java
    public ListNode reverseList(ListNode head) {
        //迭代法
        ListNode prev = null;
        ListNode curr = head;
        while(curr != null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
```



## leetcode#225 [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

- 两个队列实现栈

```java
class MyStack {

    //存储元素
    Queue<Integer> queue1;
    //辅助队列
    Queue<Integer> queue2;
    //栈的特性，后进先出
    //队列的特性，先进先出
    public MyStack() {
        queue1 = new ArrayDeque<>();
        queue2 = new ArrayDeque<>();
    }
    
    public void push(int x) {
        //插入元素到queue2中
        queue2.offer(x);
        //栈的特性为后进先出，把原来queue1中的元素也放进queue2中
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        Queue<Integer> tmp = queue1;
        queue1 = queue2;
        queue2 = tmp;
    }

    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```



- 一个队列实现栈

```java
class MyStack {

    Queue<Integer> queue;

    //栈的特性，后进先出
    //队列的特性，先进先出
    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.offer(x);
        int n = queue.size();
        //把队列x之前的元素重新出队再入队
        for(int i=1;i<n;i++){
            queue.offer(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```



# Review
[Understanding Java threads once and for all](https://medium.com/swlh/understanding-java-threads-once-and-for-all-711f71e0ec1e)

文章介绍了thread的使用办法，比较浅，主要讲解了如何创建thread，如何使用线程，线程阻塞及唤醒。

文章最好一部分还介绍了两个竞争线程，如果一个线程执行结束，另一个线程立即结束，给出了示例。使用volatile修饰了一个结束变量，这样当期发生变化时，线程立即得知变化，线程内部通过循环结束标识，当发现竞争结束，则该线程停止执行。

# Tip
- [JVM](./Tip/jvm.md)

# Share