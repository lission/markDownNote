[TOC]

# 一、基础

## 1.1、网络分层

从不同维度，可以由3种分类方式。

- OSI七层：
应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
- TCP/IP 五层：
应用层(**应用层、表示层、会话层**)、传输层、网络层、数据链路层、物理层
- TCP/IP 四层：
应用层(应用层、表示层、会话层)、传输层、网络层、网络接口层(**数据链路层、物理层**)

## 1.2、TCP/IP 四层网络模型

为何要有TCP/IP网络模型？

对于同一台设备上的进程间通信，有很多种方式，比如管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要**网络通信**，**为兼容多种多样的设备**，就协商出了一套**通用的网络协议**。

该网络协议分层，每一层有各自的作用和职责

###  1.2.1、应用层

我们能直接接触到的就是**应用层**（Application Layer），电脑或手机使用的应用软件都是在应用层实现的。当两个不同设备的应用需要通信时，应用就把应用数据传给下一层，也就是传输层。

应用层只需要专注于为用户提供应用功能，比如 **HTTP、FTP、Telnet、DNS、SMTP**等。

**应用层是不用去关心数据是如何传输的**，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。

而且**应用层是工作在操作系统中的用户态**，**传输层及以下则工作在内核态**。

### 1.2.2、传输层

应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。传输层协议只需要服务好应用，作为**应用间数据传输的媒介**，**帮助实现应用到应用的通信**，而实际的传输功能就交给下一层。

用来**建立端口到端口的通信机制**。

> 设备：四层交换机、四层路由器

![img](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E5%BA%94%E7%94%A8%E5%B1%82.webp)

**传输层有两个传输协议，分别是TCP和UDP**。

TCP 的全称叫**传输控制协议（*Transmission Control Protocol*）**，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（*TCP Segment*）。

![img](https://raw.githubusercontent.com/lission/markdownPics/main/network/TCP%E6%AE%B5.webp)

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要**用一个编号将应用区分开来**，这个编号就是**端口**。

比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

#### 1.2.2.1、端口

- **应用程序与网卡关联的编号**
- 取值范围：0～65535	
- 系统保留端口(BSD保留端口)：0～1023	
- 用户可注册的端口范围：1024～49151
- 随机动态端口：49152～65535

#### 1.2.2.2、TCP传输控制协议

- **定义**：Transmission Control Protocol **传输控制协议**，一种**可靠传输协议**

- **长度**：无长度限制，但为了保证效率，通常不会超过IP数据包的长度(65535Byte)，确保单个TCP数据包不再分割。

- **数据结构：**

  > ![tcp](https://github.com/lission/markdownPics/blob/main/network/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)

- **交互流程**

##### 1.2.2.2.1、三次握手

  1. **建立连接，三次握手**，客户端-服务器模式
  
     > 客户端-服务端模式：
     >
     > - 主动发起建立连接的应用进程叫客户端
     > - 被动等待连接建立的应用进程叫服务端
     >
     > 三次握手过程：
     >
     > 1. 客户端向服务端发送一个SYN
   > 2. 服务端接收到SYN后，向客户端发送一个SYN_ACK
     > 3. 客户端接收到SYN_ACK后，再给服务端发送一个ACK

  2. 数据传输

  3. **连接释放，四次挥手**

##### 1.2.2.2.2、四次挥手

     > 四次挥手过程：
     >
     > 1. 客户端向服务端发送一个FIN
     > 2. 服务端接收到FIN后，向客户端发送ACK，表示我接收到了断开连接请求，客户端可以不发送数据，服务端可能还有数据在处理
     > 3. 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接了
     > 4. 客户端接收到FIN，向服务端发送ACK，表示客户端也会断开连接了

#### 1.2.2.3、UDP

- **定义**：User Datagram Protocol 用户数据报协议，一种**不可靠的传输协议**

- **长度**：有长度限制，Head 8 byte，总长度不超过655535Byte，正好放进一个IP数据包

- **数据结构：**

  > ![img](https://github.com/lission/markdownPics/blob/main/network/UDP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)

### 1.2.3、网络层

网络层（Internet Layer），**负责应用间实际的数据传输功能**。

![网络层](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E7%BD%91%E7%BB%9C%E5%B1%82.webp)

**网络层最长使用的是IP（Internet Protocol）协议**，IP 协议会**将传输层的报文作为数据部分**，再加上 **IP 包头组装成 IP 报文**，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

![IP结构](https://raw.githubusercontent.com/lission/markdownPics/main/network/IP%E7%BB%93%E6%9E%84.webp)

**网络层负责将数据==从一个设备传输到另一个设备==**，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。

一般**用 IP 地址给设备进行编号**，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。

因此，需要将 IP 地址分成两种意义：

- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；

怎么分的呢？这需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。

比如 10.100.122.0/24，后面的`/24`表示就是 `255.255.255.0` 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号，如下图：

![ip与子网掩码](https://raw.githubusercontent.com/lission/markdownPics/main/network/IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.webp)

将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到**主机号**。

![子网掩码计算器](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.webp)

**在寻址的过程中，先匹配到相同的网络号**（表示要找到同一个子网），才会去找对应的主机。

除了寻址能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此**当数据包到达一个网络节点，就需要==通过路由算法==决定下一步走哪条路径**。

路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

![路由器寻址](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AF%BB%E5%9D%80.webp)



**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**

**定义**：引入一套新的地址来区分不同的广播域/子网，这套地址叫做网络地址

> 设备：路由器、三层交换机

#### IP(网际互联协议 Internet Protocol)
- IP的作用：

  - 为每一台计算机分配IP地址
  - 确定哪些地址在同一个子网络中

- IP地址

  - IP地址分类

    - IPv4

      > 网络地址由**32位二进制数表示**
      > 通常写为**4段十进制数**
      > 取值范围0.0.0.0~255.255.255.255

    - IPv6

  - IP地址构成

    - 网络部分，用来标识子网
    - 主机部分，用来标识主机

- 子网掩码，表示子网络特征的一个参数，**形式上等同于IP地址，网络部分全为1，主机部分全为0**

  > 使用方法：将两个ip地址分别与子网掩码进行&运算，结果相同则说明两个ip在同一子网种

- IP数据包，直接放入以太网的Data部分，以太网数据包Data最长1500Byte，因此若IP数据包超过此长度， 会被分割为多个以太网数据包，分开发送

  > 构成:
  >
  > - Head，20～60Byte
  > - Data，最长65515Byte 

- ARP，用于实现从IP地址到MAC地址的映射

### 1.2.4、网络接口层

生成了 IP 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。

![网络接口层](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.webp)



IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。**以太网就是一种在==「局域网」==内，把附近的==设备连接起来==，使它们之间可以==进行通讯==的技术**。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在**以太网进行通讯要用到 MAC 地址**。

**MAC 头部是以太网使用的头部**，它包含了**接收方和发送方的 MAC 地址等信息**，我们可以通过 **ARP 协议获取对方的 MAC 地址**。

**网络接口层主要为网络层提供「链路级别」传输的服务**，负责在以太网、WiFi 这样的**底层网络上发送原始数据包**，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

### 1.2.5、总结

TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

![网络四层](https://raw.githubusercontent.com/lission/markdownPics/main/network/TCPIP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BA%A7.webp)

![网络数据结构](https://raw.githubusercontent.com/lission/markdownPics/main/network/TCPIP%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F.webp)

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

## ~~数据链路层~~

定义对高低电平进行分组方式

> 设备：网桥、以太网交换机、网卡

Ethernet以太网，以太网协议：

- 帧，一组电平信号构成一个数据包，叫做帧

  > 构成:
  >
  > - Head，固定18字节：
  >   - 发送者/源地址：6Byte、
  >   - 接受者/目标地址:6Byte
  >   - 数据类型：6Byte
  > - Data，最短46Byte，最长1500Byte
  > 
  > 长度：最短64字节，最长1518字节，超过此长度就分片发送
  
- MAC地址

- Broadcast广播，Ethernet**使用广播方式进行通信**

## ~~物理层~~

高电平用1表示，低电平用0表示，高低是一个相对概念

> 设备：中继器、集线器、双绞线



## 1.3、键入网址到网页显示，期间发生了什么

![img](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.webp)



### 1.3.1、孤单小弟—HTTP

> **浏览器做的第一步工作是解析 URL**

首先浏览器做的第一步工作就是要对 `URL` 进行解析，从而生成发送给 `Web` 服务器的请求信息

URL各个元素代表含义；

![url各元素含义](https://raw.githubusercontent.com/lission/markdownPics/main/network/URL%E5%90%84%E4%B8%AA%E5%85%83%E7%B4%A0%E5%90%AB%E4%B9%89.webp)

URL 实际上是**请求服务器里的文件资源**。

当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了。

> 生成 HTTP 请求信息

对 `URL` 进行解析之后，**浏览器确定了 Web 服务器和文件名**，接下来就是根据这些信息来生成 HTTP 请求消息了。

![http请求消息](https://raw.githubusercontent.com/lission/markdownPics/main/network/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.webp)



### 1.3.2、真实地址查询—DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

有一种服务器就专门**保存了 `Web` 服务器域名与 `IP` 的对应关系**，它就是 `DNS` 服务器。

> 域名的层级关系

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。

实际上域名最后还有一个点，比如 `www.server.com.`，这个**最后的一个点代表根域名**。

`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

![域名层级结构](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E5%9F%9F%E5%90%8D%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.webp)

根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。

任何 DNS 服务器就都可以找到并访问根域 DNS 服务器。

客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

> 域名解析的工作流程

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给**本地 DNS 服务器**（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” **根域名服务器是最高层次的，它不直接用于域名解析**，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问**权威 DNS 服务器**：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，**它是域名解析结果的原出处**。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

![DNS解析过程](https://raw.githubusercontent.com/lission/markdownPics/main/network/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.webp)

> 那是不是每次解析域名都要经过那么多的步骤呢？

当然不是了，还有缓存这个东西的嘛。

浏览器会先看自身有没有对这个**域名的缓存**，如果有，就直接返回，如果没有，就去问操作系统，**操作系统也会去看自己的缓存**，如果有，就直接返回，如果没有，再去 **hosts 文件**看，也没有，才会去问「本地 DNS 服务器」。



### 1.3.3、指南好帮手—协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。	

![协议栈内部划分](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%86%85%E9%83%A8%E5%88%92%E5%88%86.webp)

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于**根据 IP 地址查询相应的以太网 MAC 地址**。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

## 1.3.4、可靠传输—TCP

**HTTP 是基于 TCP 协议传输的**，所以在这我们先了解下 TCP 协议。

![img](https://raw.githubusercontent.com/lission/markdownPics/main/network/tcp%E6%8A%A5%E6%96%87%E5%A4%B4.webp)

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为**三次握手**。

这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。

![img](https://raw.githubusercontent.com/lission/markdownPics/main/network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp)

三次握手目的是**保证双方都有发送和接收的能力**。

> 如何查看 TCP 的连接状态？

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![tcp连接状态](https://raw.githubusercontent.com/lission/markdownPics/main/network/tcp%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81.webp)



> TCP 分割数据

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![tcp分割数据](https://raw.githubusercontent.com/lission/markdownPics/main/network/tcp%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE.webp)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![tcpmutmss](https://raw.githubusercontent.com/lission/markdownPics/main/network/tcpmtumss.webp)

> TCP 报文生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

至此，网络包的报文如下图。

![tcphttp](https://raw.githubusercontent.com/lission/markdownPics/main/network/tcp%E5%A4%B4%E9%83%A8http%E6%8A%A5%E6%96%87.webp)

## 远程定位 —— IP

TCP 模块在执行**连接、收发、断开**等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

> IP 包头格式

![ip报文头](https://raw.githubusercontent.com/lission/markdownPics/main/network/ip%E6%8A%A5%E6%96%87%E5%A4%B4.webp)

在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：

- 源地址IP，即是客户端输出的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。

> 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。

在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。

![路由表](https://raw.githubusercontent.com/lission/markdownPics/main/network/linux%E8%B7%AF%E7%94%B1%E8%A1%A8.webp)

根据上面的路由表，我们假设 Web 服务器的目标地址是 `192.168.10.200`。

![路由表匹配](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%8C%B9%E9%85%8D.webp)

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

> IP 报文生成

![ip报文](https://raw.githubusercontent.com/lission/markdownPics/main/network/ip%E6%8A%A5%E6%96%87.webp)

## 两点传输 —— MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

> MAC 包头格式

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

![mac包头格式](https://raw.githubusercontent.com/lission/markdownPics/main/network/mac%E5%8C%85%E5%A4%B4%E6%A0%BC%E5%BC%8F.webp)

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

> MAC 发送方和接收方如何确认?

**发送方**的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

**接收方**的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了。

> 既然知道要发给谁，按如何获取对方的 MAC 地址呢？

此时就需要 `ARP` 协议帮我们找到路由器的 MAC 地址。

![arp](https://raw.githubusercontent.com/lission/markdownPics/main/network/arp%E5%8D%8F%E8%AE%AE.webp)

ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

> 查看 ARP 缓存内容

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。

![arp缓存](https://raw.githubusercontent.com/lission/markdownPics/main/network/arp%E7%BC%93%E5%AD%98.webp)

> MAC 报文生成

至此，网络包的报文如下图。

![网络包](https://raw.githubusercontent.com/lission/markdownPics/main/network/mac%E7%BD%91%E7%BB%9C%E6%8A%A5%E6%96%87.webp)

## 出口 —— 网卡

**网络包**只是存放在内存中的**一串二进制数字信息**，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。

网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

![网卡部分](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BD%91%E5%8D%A1%E8%B4%9F%E8%B4%A3%E7%9A%84%E9%83%A8%E5%88%86.webp)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

最后**网卡会将包转为电信号，通过网线发送出去**。

## 送别者 —— 交换机

交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。

> 交换机的包接收操作

首先，电信号到达网线接口，交换机里的模块进行接收，接下来**交换机里的模块将电信号转换为数字信号**。

然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有 MAC 地址**。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

![交换机](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E4%BA%A4%E6%8D%A2%E6%9C%BA.webp)

举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。

所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

> 当 MAC 地址表找不到指定的 MAC 地址会怎么样？

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能**将包转发到除了源端口之外的所有端口上**，无论该设备连接在哪个端口上都能收到这个包。

这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后**目标设备会作出响应**，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

> 数据包通过交换机转发抵达了路由器

## 出境大门 —— 路由器

> 路由器与交换机的区别

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

> 路由器基本原理

路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

> 路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

> 查询路由表确定输出端口

完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![路由表](https://raw.githubusercontent.com/lission/markdownPics/main/network/%E8%B7%AF%E7%94%B1%E8%A1%A8.webp)

具体的工作流程根据上图，举个例子。

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。

> 路由器的发送操作

接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址不是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

> 数据包通过多个路由器的帮助，在网络世界途经了很多路程，目的地！目的地的路由器，发现了这个数据包原来是发给自己服务的，于是它就将数据包转发，经由交换机帮助下，最终转发到了目的地了。

## 互相扒皮 —— 服务器 与 客户端

数据包抵达了服务器，服务器开始进行数据包解析。









# HTTP

HTTP是应用层的协议，HTTP协议是建立在TCP协议基础之上的。**WEB使用HTTP协议作为应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输协议将它发送到网络上**。

