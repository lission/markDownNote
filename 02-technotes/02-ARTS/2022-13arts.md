09.06~09.13

[TOC]

# Algorithm

- leetcode 34 [二分查找单一元素](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

## 遍历法，O(n)

  ```java
  public int[] searchRange(int[] nums, int target) {
    int start = -1;
    int end = -1;
    for(int i=0;i<nums.length;i++){
      if(nums[i] == target){
        if(start == -1){
          start = i;
        }
        end = i;
      }
    }
    return new int[]{start,end};
  }
  ```

## 二分查找法，O(logn)

```java
public int[] searchRange(int[] nums, int target) {
        int left = search(nums,target);
        int right = search(nums,target + 1) - 1;
        if(left <= right && nums[left] == target && nums[right] == target){
            return new int[]{left,right};
        }
        return new int[]{-1,-1};
    }

    public int search(int[] nums,int target){
        int left = 0,right = nums.length;
        while(left < right){
            int mid = (left + right) >> 1;
            if(nums[mid] >= target){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left;
    }
```

# Review

- The Lord Of The Rings，Note On The Text，Note On The 50TH ANNIVERSARY EDITION，FORWORD TO THE SECOND EDITION

# Tip

- How to design hash map，[参考地址](https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)

```java
/**
 * 设计hashMap
 * Constraints and assumptions（约束和假设）
 * For simplicity, are the keys integers only? Yes
 * 为了简单，key只支持Integer
 * For collision resolution, can we use chaining? Yes
 * 哈希碰撞解决方案，使用拉链法
 * Do we have to worry about load factors? No
 * 无需考虑负载因子
 * Can we assume inputs are valid or do we have to validate them? Assume they're valid
 * 可以假定输入参数都是有效的
 * Can we assume this fits memory? Yes
 *
 * @author lisong@cestc.cn
 * @date 2022/9/7
 */
public class SelfHashMap {

    class Item{
        Integer key;
        Integer value;
        Item next;

        public Item(Integer key, Integer value,Item next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    private int size;
    private Item[] table;

    public SelfHashMap(int size) {
        this.size = size;
        this.table = new Item[size];
    }

    private int hash(Integer key){
        return key.hashCode() & (table.length-1);
    }

    public void set(Integer key,Integer value){
        int index = hash(key);
        if (table[index] == null){
            table[index] = new Item(key,value,null);
        }else {
            Item item = table[index];
            do {
                if (Objects.equals(item.key, key)){
                    item.value = value;
                }
                item = item.next;
            } while (item.next != null);
            item.next = new Item(key,value,null);
        }
    }

    public Integer get(Integer key){
        int index = hash(key);
        if (table[index] == null){
            System.out.println(" get Key not found:"+key);
            return null;
        }else {
            Item item = table[index];
            do {
                if (Objects.equals(item.key, key)){
                    return item.value;
                }
                item = item.next;
            } while (item.next != null);
        }
        System.out.println("get Key not found:"+key);
        return null;
    }

    public Integer remove(Integer key){
        int index = hash(key);
        if (table[index] == null){
            System.out.println("remove Key not found:"+key);
            return null;
        }else {
            Item item = table[index];
            Integer value = null;
            do {
                if (Objects.equals(item.key, key)){
                    value = item.value;
                    item = null;
                    break;
                }
                item = item.next;
            } while (item.next != null);
            if (value == null){
                System.out.println("remove Key not found:"+key);
                return null;
            }
            if (table[index].next == null){
                table[index] = null;
            }
            return value;
        }

    }

    public static void main(String[] args) {
        SelfHashMap hashMap = new SelfHashMap(10);
        hashMap.set(1,1);
        hashMap.set(2,2);
        System.out.println(hashMap.get(1));
        System.out.println(hashMap.get(2));
        hashMap.remove(1);
        System.out.println(hashMap.get(1));
        hashMap.remove(1);
    }
}
```




# Share

