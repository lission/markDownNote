09.26~10.02

[TOC]

# Algorithm



# Review

- The Lord Of The Rings，PROLOGUE


# Tip

## SpringBoot启动过程及自动配置原理

[参考地址](https://zhuanlan.zhihu.com/p/136469945)

### SpringBoot启动过程

#### 启动原理相关源码

- **创建SpringApplication对象**

  ```java
  public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { 
  	this.sources = new LinkedHashSet(); 
  	this.bannerMode = Mode.CONSOLE; 
  	this.logStartupInfo = true; 
  	this.addCommandLineProperties = true; 
  	this.addConversionService = true; 
  	this.headless = true; 
  	this.registerShutdownHook = true; 
  	this.additionalProfiles = new HashSet(); 
  	this.isCustomEnvironment = false; 
  	this.resourceLoader = resourceLoader; 
  	Assert.notNull(primarySources, "PrimarySources must not be null"); 
  	// 保存主配置类（这里是一个数组，说明可以有多个主配置类） 
  	this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); 
  	// 判断当前是否是一个 Web 应用 
  	this.webApplicationType = WebApplicationType.deduceFromClasspath(); 
  	// 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationContextInitializer，然后保存起来 
  	this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); 
  	// 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationListener，然后保存起来 
  	this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); 
  	// 从多个配置类中找到有 main 方法的主配置类（只有一个） 
  	this.mainApplicationClass = this.deduceMainApplicationClass(); 
  }
  ```

- **运行run()方法**

  ```java
  public ConfigurableApplicationContext run(String... args) { 
  
  // 创建计时器 
  StopWatch stopWatch = new StopWatch(); 
  stopWatch.start(); 
  // 声明 IOC 容器 
  ConfigurableApplicationContext context = null; 
  Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList(); 
  this.configureHeadlessProperty(); 
  // 从类路径下找到 META/INF/Spring.factories 获取 SpringApplicationRunListeners 
  SpringApplicationRunListeners listeners = this.getRunListeners(args); 
  // 回调所有 SpringApplicationRunListeners 的 starting() 方法 
  listeners.starting(); 
  Collection exceptionReporters; 
  try { 
  // 封装命令行参数 
  ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 
  // 准备环境，包括创建环境，创建环境完成后回调 SpringApplicationRunListeners#environmentPrepared()方法，表示环境准备完成 
  ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); 
  this.configureIgnoreBeanInfo(environment); 
  // 打印 Banner 
  Banner printedBanner = this.printBanner(environment); 
  // 创建 IOC 容器（决定创建 web 的 IOC 容器还是普通的 IOC 容器） 
  context = this.createApplicationContext(); 
  exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context); 
  /*
   * 准备上下文环境，将 environment 保存到 IOC 容器中，并且调用 applyInitializers() 方法
   * applyInitializers() 方法回调之前保存的所有的 ApplicationContextInitializer 的 initialize() 方法
   * 然后回调所有的 SpringApplicationRunListener#contextPrepared() 方法 
   * 最后回调所有的 SpringApplicationRunListener#contextLoaded() 方法 
   */
  this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); 
  // 刷新容器，IOC 容器初始化（如果是 Web 应用还会创建嵌入式的 Tomcat），扫描、创建、加载所有组件的地方 
  this.refreshContext(context); 
  // 从 IOC 容器中获取所有的 ApplicationRunner 和 CommandLineRunner 进行回调 
  this.afterRefresh(context, applicationArguments); 
  stopWatch.stop(); 
  if (this.logStartupInfo) { 
  (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); 
  } 
  // 调用 所有 SpringApplicationRunListeners#started()方法 
  listeners.started(context); 
  this.callRunners(context, applicationArguments); 
  } catch (Throwable var10) { 
  this.handleRunFailure(context, var10, exceptionReporters, listeners); 
  throw new IllegalStateException(var10); 
  } 
  try { 
  listeners.running(context); 
  return context; 
  } catch (Throwable var9) { 
  this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); 
  throw new IllegalStateException(var9); 
  } 
  }
  ```

#### 启动流程

- 通过启动类的main()方法进入，内部是SpringApplication.run()方法，以下为调用链：

  > `SpringApplication.run()` -> `run(new Class[]{primarySource}, args)` -> `(new SpringApplication(primarySources)).run(args)`

- run()方法主要包括两大步骤：

  - **创建SpringApplication对象**
  - **运行run()方法**

- **创建SpringApplication对象**，在**SpringApplication的构造函数**中：

  - 先保存主配置类（这里是一个数组，说明可以有多个主配置类） 
  - 接着判断应用是否为web应用
  - 从类路径下找到 META/INF/Spring.factories 配置的所有 **ApplicationContextInitializer**，然后保存起来。（初始化上下文）
  - 从类路径下找到 META/INF/Spring.factories 配置的所有 **ApplicationListener**，然后保存起来。（初始化监听）
  - 从多个配置类中找到有 main 方法的主配置类（只有一个）

- **运行run()方法**

  - 声明 IOC 容器 
  - 从类路径下找到 META/INF/Spring.factories 获取 **SpringApplicationRunListeners**
  - 回调所有 SpringApplicationRunListeners 的 starting() 方法
  - 封装命令行参数
  - 准备环境，包括创建环境，创建环境完成后回调 SpringApplicationRunListeners#environmentPrepared()方法，表示环境准备完成 
  - 创建 IOC 容器（决定创建 web 的 IOC 容器还是普通的 IOC 容器） 
  - 准备上下文环境，将 environment 保存到 IOC 容器中，并且调用 applyInitializers() 方法。applyInitializers() 方法回调之前保存的所有的 ApplicationContextInitializer 的 initialize() 方法。然后回调所有的 SpringApplicationRunListener#contextPrepared() 方法 。最后回调所有的 SpringApplicationRunListener#contextLoaded() 方法   
  - 刷新容器，IOC 容器初始化（如果是 Web 应用还会创建嵌入式的 Tomcat），扫描、创建、加载所有组件的地方 
  - 从 IOC 容器中获取所有的 ApplicationRunner 和 CommandLineRunner 进行回调 
  - 调用 所有 SpringApplicationRunListeners#started()方法 

  > spring启动过程中主要相关的4个监听器：
  >
  > - ApplicationContextInitializer
  > - ApplicationRunner
  > - CommandLineRunner
  > - SpringApplicationRunListener
  >
  > **run() 阶段主要就是回调4个监听器中的方法与加载项目中组件到 IOC 容器中**，而所有需要回调的监听器都是从类路径下的 `META/INF/Spring.factories` 中获取，从而达到启动前后的各种定制操作。

#### 简易总结

1. 获取并启动监视器
2. 构造应用上下文环境
3. 初始化应用上下文
4. 刷新应用上下文前的准备阶段
5. 刷新应用上下文
6. 刷新应用上下文后的扩展接口

## SpringBoot starter的原理

springboot starter是一个集成接合器，也叫做**场景启动器**。完成两件事：

1. **引入模块所需的相关jar包**
2. **自动配置各自模块所需的属性**（springboot按照某种默认的规则替我们完成自动配置的工作，这个规则就是**约定大于配置**）

## SpringBoot自动配置原理

- SpringBoot的**自动配置在启动类的@SpringBootApplication注解中进行处理**

  > @SpringBootApplication标注在某个类上说明：
  >
  > - 这个类是**SpringBoot的主配置类**
  > - SpringBoot应**运行这个类的main方法启动SpringBoot应用**

- @SpringBootApplication注解是一个**组合注解**

  > 核心了解三个注解：
  >
  > - **@SpringBootConfiguration**，该注解表示这是一个**SpringBoot的配置类**，其实它就是一个@Configuration注解
  > - **@ComponentScan**，**开启组件扫描**
  > - **@EnableAutoConfiguration**，**该注解开启自动配置**

- @EnableAutoConfiguration注解

  > ```java
  > @AutoConfigurationPackage 
  > @Import({AutoConfigurationImportSelector.class}) 
  > public @interface EnableAutoConfiguration { 
  >   ……
  > }  
  > ```

  - **@AutoConfigurationPackage，自动配置包**，内部导入了Registrar组件。该注解就是**将主配置类的所在包及下面所有子包里面的所有组件扫描到Spring容器**。
  - 配置类导入规则，@Import({AutoConfigurationImportSelector.class}) ，AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()返回需要导入的组件的全类名数组。
    - localFactoryNames()中关键的三步：
      1. 从当前项目的类路径中获取所有META/spring.factories这个文件文件的信息
      2. 将上面获取到的信息封装成一个Map返回
      3. 从返回的Map中通过刚才传入的EnableAutoConfiguration.class参数，获取该key下的所有参数。

  > META/spring.factories探究：
  >
  > 将类路径下META/spring.factories里面配置的所有EnableAutoConfiguration的值加入到Spring容器中

  - 自动配置类中，有一个@EnableConfigurationProperties注解，它后面的参数是一个ServerProperties类，该注解把**配置文件中的配置项**与其**参数类绑定上了**，自动配置类又引用了对应的ServerProperties，所以最后就能在自动配置类中使用配置文件中的值了。最终**通过@Bean和一些条件判断**往容器中添加组件，实现自动配置。这就是**约定大于配置的最终落地点**

  > **HttpEncodingAutoConfiguration**自动配置类示例：
  >
  > ```java
  > @Configuration 
  > @EnableConfigurationProperties({HttpProperties.class}) 
  > @ConditionalOnWebApplication( 
  > type = Type.SERVLET 
  > ) 
  > @ConditionalOnClass({CharacterEncodingFilter.class}) 
  > @ConditionalOnProperty( 
  > prefix = "spring.http.encoding", 
  > value = {"enabled"}, 
  > matchIfMissing = true 
  > ) 
  > public class HttpEncodingAutoConfiguration { 
  > ```
  >
  > - @Configuration：标记为配置类。
  > - @ConditionalOnWebApplication：web应用下才生效。
  > - @ConditionalOnClass：指定的类（依赖）存在才生效。
  > - @ConditionalOnProperty：主配置文件中存在指定的属性才生效。
  > - @EnableConfigurationProperties({HttpProperties.class})：启动指定类的ConfigurationProperties功能；将配置文件中对应的值和 HttpProperties 绑定起来；并把 HttpProperties 加入到 IOC 容器中。
  >
  > 1. @EnableConfigurationProperties({HttpProperties.class}) 把配置文件中的配置项与当前 HttpProperties 类绑定上了
  > 2. 然后在 HttpEncodingAutoConfiguration 中又引用了 HttpProperties ，所以最后就能在 HttpEncodingAutoConfiguration 中使用配置文件中的值了
  > 3. 最终通过 @Bean 和一些条件判断往容器中添加组件，实现自动配置。（当然该Bean中属性值是从 HttpProperties 中获取）
  >
  > **HttpProperties**
  >
  > > HttpProperties 通过 @ConfigurationProperties 注解将配置文件与自身属性绑定。所有在配置文件中能配置的属性都是在 xxxProperties 类中封装着

### 自动配置生效条件

- @ConditionalOnBean：当容器里有指定的bean的条件
- @ConditionalOnMissingBean：当容器里不存在指定bean的条件下
- @ConditionalOnClass：当类路径下有指定类的条件下
- @ConditionalOnMissingClass：当类路径下不存在指定类的条件下
- @ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix="xxx.xxx",value="enable",matchIfMissing=true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。

 


# Share

## 未来简史-第六章-与“现代”的契约



## 未来简史-第七章-人文主义革命

