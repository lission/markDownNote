[TOC]

# mysql架构

## mysql的执行流程

**查询流程**

![img](https://github.com/lission/markdownPics/blob/main/mysql/MySQL%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png?raw=true)

- 连接

- 查询缓存，mysql内部自带一个缓存模块，MySQL 的缓存默认是关闭的。**在 MySQL8.0 中，查询缓存已经被移除了。**

  > MySql自带缓存应用场景有限：
  >
  > - SQL 语句必须一模一样，中间多一个空格，字母大小写不同，都会被认为是不同的 SQL 
  > - 表中任意一条数据发生变化的时候，这张表的缓存都会失效。所以，对于有大量数据更新的应用，也不合适
  >
  > **所以缓存这一块，我们还是交给 ORM 框架（比如 MyBatis 默认开启了一级缓存），或者独立的缓存服务，比如 Redis 来处理更为合适。**

- 解析器，Parser 解析器，对语句基于 SQL 语法进行词法和语法分析，以及语义的解析。语法解析是根据 SQL 语句生成一个数据结构。**这个结构我们把它叫做解析树**
- 预处理器，Preprocessor，**它会检查生成的解析树，解决解析器无法分析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。**预处理之后得到一个新的解析树。
- 查询优化器，Optimizer，查询优化器的目的就是根据解析树生成不同的`执行计划（Execution Plan）`，然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种。
- 执行计划。Execution Plan，查询优化器基于解析树以最小开销原则生成选择执行计划
- 执行引擎和存储引擎，执行引擎利用存储引擎提供的相应的 API 来完成操作，最后把数据返回给客户端



## mysql架构分层

总体上，我们可以把 MySQL 分成三层。

- 跟客户端对接的连接层
- 执行操作的服务层
- 和硬件打交道的存储引擎层

![img](https://github.com/lission/markdownPics/blob/main/mysql/MySQL%20%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82.png?raw=true)

## mysql中一条更新sql是如何执行的

update操作其实包括更新、插入和删除。更新流程与查询流程基本一致，也要经过解析器、优化器的处理最后交给执行器，区别在于拿到符合条件的数据之后的操作。

> MyBatis源码Executor里也只有doQuery()和doUpdate()方法，没有doDelete() 和 doInsert()

简化的更新操作流程：

- 1、事务开始，从内存（Buffer pool）或磁盘（data file）取到包含这条数据的数据页，返回给Server执行器
- 2、server执行器修改数据页的数据值
- 3、记录原数据至undo log
- 4、记录更新数据至redo log
- 5、调用存储引擎接口，记录数据页到Buffer pool
- 6、事务提交

**redo log 和 undo log与事务密切相关，统称为事务日志**



# 存储引擎

## MyISAM

> 不支持事务，性能更好，数据占用空间小。锁级别为表级锁，并发性差。

**数据表底层结构**

每张表对应生成三个文件

- frm文件：表结构定义文件，存储与表相关的元数据(meta)信息
- MYD文件：MyISAM存储引擎专用，存放MyISAM表的数据(data)
- MYI文件：MyISAM存储引擎专用，存放MyISAM表的索引相关信息

**mysql8.0从元数据中移除了frm文件**

**适用场景**

- 非事务型应用
- 只读类应用(可以压缩表)，存档数据

## InnoDB

> Mysql 5.7中的默认存储引擎，InnoDB是一个事务安全存储引擎。支持行级锁和表锁，支持读写并发，写不阻塞(MVCC)。InnoDB 将用户数据存储在`聚集索引`中(索引和记录在一起存储)，以减少基于主键的常见查询 I/O 。

InnoDB 对应两个文件： 表结构文件 `.frm `、数据文件 `.ibd`；表最大为 64TB。

**适用场景**

- 经常更新表，存在并发读写或者有事务处理的业务系统
- 并发业务多，需要考虑读写互不干扰，保证比较高的数据一致性的场景

## MyISAM和InnoDB对比

- 事务和外键
  - InnoDB支持事务，具有安全性和完整性，适合大量insert和update操作
  - MyISAM不支持事务，提供高速检索，适合大量select操作
- 锁机制
  - InnoDB支持行级锁和表级锁，基于索引实现
  - MyISAM只支持表级锁
- 索引结构
  - InnoDB使用**聚集索引(聚簇索引)，索引和记录在一起存储**
  - MyISAM使用**非聚集索引(非聚簇索引)，索引和记录分开存储**
- 并发处理能力
  - InnoDB读写阻塞与隔离级别有关，可以采用多版本并发控制MVCC支持高并发
  - MyISAM使用表锁，写操作并发率低，读写阻塞
- 存储文件
  - InnoDB 对应两个文件： 表结构文件 `.frm `、数据文件 `.ibd`；表最大为 64TB。
  - MyISAM 对应三个文件：表结构文件 `.frm`、表数据文件`.MYD`、索引文件`.MYI`；从 MySQL5.0 开始默认限制是 256TB
  - **mysql8.0从元数据中移除了frm文件**
- 适用场景
  - InnoDB读写阻塞与隔离级别有关，可以采用多版本并发控制MVCC支持高并发
    - 经常更新表，存在并发读写或者有事务处理的业务系统
    - 并发业务多，需要考虑读写互不干扰，保证比较高的数据一致性的场景
  - MyISAM
    - 非事务型应用
    - 只读类应用(可以压缩表)，存档数据

## InnoDB核心概念

### 缓冲池 Buffer Pool

对InnoDB存储引擎来说，数据都是放在磁盘上的，存储引擎要操作数据必须先把磁盘里面的数据加载到内存里面才可以操作。磁盘I/O的读写相对于内存操作很慢，操作系统、内存引擎都有一个**预读取**的概念。

> 预读取：依据局部性原理（当磁盘上一块数据被读取时，很可能它附近的位置夜会被读取。）每次多读取一点，而不是用多少读多少。***可以分为线性预读、随机预读***
>
> InnoDB设定了存储引擎从磁盘读取数据到内存的最小单位，页page。操作系统的默认page大小4kb，InnoDB默认page大小为16kb，如果修改值，需要清空数据重新初始化服务。

**InnoDB设计缓冲区Buffer Pool默认大小128M，作用就是来提升读写效率**。

- 读取数据时，先判断是不是在这个buffer pool，如果是直接读取；如果不是，再从磁盘加载。读取到的数据写到这个内存缓冲区。

- 修改数据时，也是先写到这个buffer pool，而不是直接写进磁盘。**内存数据页未同步至磁盘前，称之为脏页**。InnoDB有专门的后台线程把buffer pool数据写入磁盘，往磁盘同步时称之为**刷脏**。

#### 缓冲池管理，LRU

InnoDB按照page页的方式管理数据，使用LRU(最近最少使用)算法进行page管理。

**【普通 LRU 算法】**

LRU 列表头部为使用最频繁的 Page，尾部为最少使用的 Page。当内存不足继续从磁盘读取 Page 时，释放尾部的 Page。

**【存在的问题】**

有一些操作需要访问表中的许多页，甚至全部页（如：索引 or 数据的扫描操作），**这些页仅在这次查询操作中需要，并非热点数据**；

**如果直接把这些页放到 LRU 列表头部，那么就会有很多热点数据页被刷新出去，影响缓冲池效率，而且下次读取得重新访问磁盘。**

【引入改良版 LRU 算法】

- 使用 **中点插入策略（midpoint insertion strategy）**，把LRU list分成两部分，靠近head的叫做new sublist，存放热数据，叫它热区；靠近tail部分的叫做old sublist，存放冷数据，叫它冷区。中割线称为midpoint，最新访问的页放入 LRU 列表的 midpoint 位置。
- midpoint 可以通过参数 `innodb_old_blocks_pct` 设置，默认为 37，即 LRU 列表从尾部开始 37% 的位置（约 3/8）。热区占5/8，冷区占3/8

### redo log

**问题**：刷脏不是实时的，如果buffer pool里的脏页还没有刷入磁盘，数据库宕机或重启，这些数据会丢失。

为了避免这个问题**（刷脏不及时导致的数据丢失）**，InnoDB把所有对页page的**修改操作**专门写入一个日志文件即**磁盘的redo log(重做日志)**，如果有未同步到磁盘的数据数据库在启动时，会从这redo log进行恢复操作(crash-safe)。事务中ACID中的D(持久性)就是用redo log实现的。

redo log位于/var/lib/mysql目录下，**ib_logfile0和ib_logfile1，默认2个文件，每个48M**

redo log特点：

- redo log是InnoDB存储引擎实现的，**支持崩溃恢复**是InnoDB的一个特性
- redo log不是记录数据页更新之后的状态，而是记录**在这个数据页上做了什么修改**。属于物理日志
- redo log **大小固定，前面的内容会被覆盖，一旦写满，就会触发buffer pool到磁盘的同步**，以便腾出空间记录后面的修改

> **同样是写磁盘，为什么不直接写到db file里面去？为什么先写日志再写磁盘？写日志文件和写到数据文件有什么区别？**
>
> - 刷盘是随机I/O，数据可能存储在磁盘不同的扇区中，找到对应的数据需要磁臂旋转到自定页，然后盘片找到对应扇区，找到需要的一块数据，直至找到所有数据，读写速度慢。
> - 记录日志是顺序I/O，找到了第一块数据，其他数据就在这块数据后边，不需要重新寻址。顺序I/O效率更高。
>
> **二者本质上是数据集中存储和分散存储的区别，先把修改写入日志文件，保证了内存数据的安全性的情况下，延迟刷盘时机，提升吞吐性。**

### undo log

又叫撤销日志或回滚日志，记录了事务发生之前的数据状态，分别为insert undo log和update undo log。修改数据时出现异常，**可以用undo log实现回滚操作（保持原子性）**

updo log可以理解为记录的是反向操作，比如insert 会记录delete，称为逻辑格式日志



## InnoDB 内存结构

[官网地址](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)

![innodb-architecture.png](https://github.com/lission/markdownPics/blob/main/mysql/innodb-architecture.png?raw=true)

- Buffer pool，**InnoDB设计缓冲区Buffer Pool默认大小128M，作用就是来提升读写效率**。管理存储预读取的数据页

  - Change Buffer，写缓冲，是Buffer Pool的一部分，如果一个数据页不是唯一索引，不存在数据重复情况，也就不需要从磁盘加载索引页判断数据是否重复(唯一性检查)。这种情况可以先把修改记录在内存的缓冲池中，提升更新语句的执行速度

- Log Buffer，日志缓存，日志信息会先放到缓冲区，然后按照一定频率刷新到日志文件。日志包含：

  - InnoDB 引擎日志
  - 数据库操作时产生的 redo 和 undo 日志

  > Log Buffer 写入磁盘的时机，由一个参数控制，默认是 1 。
  >
  > | 值                            | 含义                                                         |
  > | ----------------------------- | ------------------------------------------------------------ |
  > | 0（延迟写）                   | log buffer 将每秒执行一次的写入 log file 中，并且 log file 的 flush 操作同时进行。 该模式下，在事物提交的时候，不会触发主动写入磁盘的操作。 |
  > | ==1（默认，实时写，实时刷）== | ==每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。并且刷新到磁盘中去。== |
  > | 2 （延时写，延时刷）          | 每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。 |

- Adaptive Hash Index，自适应hash索引，用户不可以显示的创建 Hash Index ，只能由 InnoDB 自己维护，一般用在 Buffer Pool 。**InnoDB 自动为 Buffer Pool 中的热点页创建的索引**）

## InnoDB 后台线程

后台线程的主要作用是**负责刷新内存池中的数据和把修改的数据页刷新到磁盘**。后台线程分为：master thread，IO thread，purge thread，page cleaner thread。

- **master thread** 负责刷新缓存数据到磁盘，并协调调度其他后台线程。
- **IO thread** 分为 insert buffer、log 、read 、write 进程。分别用来处理 insert buffer、重做日志、读写请求的 IO 回调。
- **purge thread** 用来回收 undo 页。
- **page cleaner thread**= 用来刷新脏页。

## bin log

MySQL 的 Server 层也有一个日志文件，叫做 **binlog** ，它**可以被所有的存储引擎使用**。binlog 以事件的形式记录了所有的 DDL 和 DML 语句（因为**记录的是操作而不是数据值，数据逻辑日志**），可以用来做**主从复制和数据恢复**。
跟 redo log 不一样，它的内容是可以追加的，没有固定大小限制。在开启了 binlog 功能情况下，我们可以吧 binlog 导出成 SQL 语句，把所有操作重放一遍，来**实现数据恢复**

## bin log与redo log

二进制日志（binlog）是用来进行 POINT-IN-TIME（PIT）**特定时间点的恢复以及主从复制环境的建立**。

从表面上看，binlog 和 redo log 都是记录对数据库操作的日志，但两者有很大的不同：

- 产生位置不同：
  - redo log 只是 InnoDB 存储引擎层产生的
  - binlog 在任何存储引擎下都会产生
- 内容不同：
  - binlog 是逻辑日志，其记录的是对应的 SQL 语句
  - redo log 是物理日志，其记录的是对于每个页的修改
- 记录时间点不同：
  - binlog 只在事务提交完成后写入一次
  - redo log 在事务进行期间不断写入



# 索引

## 索引的分类

索引，数据库管理系统(DBMS)的一个**排序**的数据结构，以协助快速查询、更新数据库表中的数据。

### 应用层面

- 普通索引，也叫做非唯一索引，是普通索引，没有任何限制
- 唯一索引，要求键值不重复
- 主键索引，是一种特殊的唯一索引，它还多了一个限制条件，要求**键值不能为空**。主键索引用 **Primay key**创建
- 复合索引，又称为联合索引，是在多个列上创建的索引。创建复合索引最重要的是**列顺序**的选择，这关系到索引能否使用上，或者影响多少个谓词条件能使用上索引。**复合索引的使用遵循最左匹配原则**，只有索引左边的列匹配到，后面的列才能继续匹配

### 数据与键值逻辑

- 聚集索引，**(聚簇索引)，索引和记录在一起存储**，一个索引值对应一行记录。
  - 如果一张表创建了主键索引，那么主键索引就是聚簇索引
  - 如果没有主键，则为第一个非空唯一索引
  - 没有非空唯一索引，则为 InnoDB 内置的 ROWID
- 非聚集索引，**(非聚簇索引)，索引和记录分开存储**。二级索引/辅助索引，主键索引之外的索引叶子节点上存储的是这条**记录对应的主键的值**。

### 数据结构

- B树，是一种自平衡的m阶树，能够保持数据有序，B表示平衡balance。[数据结构说明](./Tip/数据结构.md)

- B+树，在B树基础上，为叶子节点增加链表指针（B树+叶子有序链表），所有关键字都在叶子节点上，非叶子节点作为叶子节点的索引。InnoDB 就是使用 B+树。[数据结构说明](./Tip/数据结构.md)

- Hash索引，查询效率高，可以一次性定位。在 InnoDB 中，不能显示地创建一个哈希索引（**所谓支持哈希索引只的 自适应哈希索引（Adaptive Hash Index），它是 InnoDB 自动为 Buffer Pool 中的热点页创建的索引**）。

  **Memory 存储引擎可以使用哈希索引**

  > 缺陷：
  >
  > - 不能用于范围查询
  > - 不能避免表扫描
  > - 大量hash重复时，性能欠佳

- FullText索引，全文索引，目前仅用于char、vachar、text这三种类型
- R树索引，比较少见，主要用于空间数据索引

## 索引的使用原则

- **列的离散度**，离散度公式：count(distinct(column_name)):count(1)，**列的全部不同值和所有数据行的比例。** **列的重复值越多，离散度就越低**，重复值越少，离散度就越高。**不建议在离散度低的字段上建立索引**
- **联合索引最左匹配原则**，联合索引在B+Tree中是复合的数据结构，按照从左到右的顺序建立搜索树
- **覆盖索引**，覆盖索引减少了IO次数，大大提升查询效率
  - 回表：非主键索引，先通过索引找到主键索引的键值，再通过主键值查出索引没有的数据，比基于主键索引的查询多扫描了一颗索引树
  - 覆盖索引：在**二级索引**里面，不管是单列索引还是联合索引，如果**select数据只用从索引中就能取得，不必从数据区中读取，避免回表，这时候的索引就叫覆盖索引**
- **索引条件下推**，index condition pushdown ，默认开启，只适用于二级索引。ICP目标是**减少访问表的完整行的读数量从而减少IO操作**。下推，指把过滤动作在存储引擎做完，不需要到server层过滤

## 索引失效

1. 索引列上使用函数(replace\SUBSTR\CONCAT\sum count avg)、表达式计算(+ - * /)

2. 字符串不加引号，出现隐式转换

3. like 前面带%
4. 负向查询，NOT LIKE 不能。!=、<>、和 NOT IN 在某些情况下可以。

**其实用不用索引最终都是优化器说了算**。优化器是**基于 cost 开销（Cost Base Optimizer），它不是基于规则（Rule-Based Optimizer），也不是基于语义。怎么开销小怎么来。**

## 索引创建

1. 在用于 where 判断、order 排序 、 join 的（on）和 group by 的字段上创建索引。


2. 索引的个数不要过多。浪费空间，更新变慢。


3. 过长的字段应使用前缀索引。

   ```sql
   CREATE TABLE `pre_test` (
   'content' varchar(20) DEFAULT NULL,
   KEY `pre_index` (`content`(6))
   )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
   ```


4. 区分度低的字段，例如性别，不要建立索引。离散度太低，导致扫描行数过多。


5. 频繁更新的值，不要作为主键索或索引。导致频繁的页分裂。


6. 随机无的值，不建议作为索引，例如身份证号、UUID。无需，导致频繁的页分裂。


7. 组合索引把离散度高（区分度高）的值放在前面。


8. 创建复合索引，而不是修改单列索引



# 事务

## 事务特性

事务的四大特性ACID

- 原子性，Atomicity，一个事务内的操作要么全部成功，要么全部失败，即事务是不可分割的单位

  > 原子性，在 innoDB 里面是通过**undo log**来实现的，它记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用 **undo log** 来实现回滚操作。(是反向操作，比如insert 会记录delete)

- 一致性，Consistent，指的是**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**。

  > 原子性，隔离性，持久性，最后都是为了实现一致性

- 隔离性，Isolation，**要求一个事务未提交前，别的事务不能感知到它的修改**。

  > 事务隔离两大实现方案：
  >
  > - 基于锁的并发控制(LBCC)，Lock Based Concurrence Control，为保证两次读取数据一致，那么读数据时，锁定要操作的数据，不允许其他事务修改。这意味着比支持并发读写，极大影响效率
  > - 多版本并发控制(MVCC)，Multi Version Concurrence Control，mysql采用这种方案，如果要让一个事务前后两次读取的数据保持一致，可以在修改数据之前给它建立一个备份叫快照，后面读取这个快照

- 持久性，Durability，**事务一旦提交，结果就是永久性的，即使宕机重启后也能恢复**。

  > 持久性是通过 **==redo log== **和 **==double write buffer（双写缓冲）== **来实现的，我们操作数据的时候，会先写到内存的 **==buffer pool==** 里面，同时记录 **==redo log==** ，如果在刷盘之前出现异常，在重启后就可以读取 ==redo log== 的内容，写入磁盘，保证数据的持久性。



## 事务并发带来的问题

- **脏读**，一个事务里面，由于其他的事务修改了数据并且没有提交，而导致了前后两次查询到的数据不一致的情况。
- **不可重复读**，一个事物读取到了其他事务已提交的数据造成前后两次读取到数据不一致的情况。
- **幻读**，同一个事务前后两次读取数据不一致，是由于其他事务插入数据造成的

> **不可重复读和幻读的区别:**
>
> ==**修改或者删除**造成的读一不一致叫做不可重复读==，==**插入**造成的读不一致叫做幻读==。

无论是脏读，还是不可重复读，还是幻读，它们都是数据库的**==读一致性==**的问题，都是在一个事务里面前后两次读取出现不一致的情况。**读一致性的问题，必须要由数据库提供一定的事务隔离机制来解决。**



## 事务隔离级别、分别解决什么问题

|          事务隔离级别           |    脏读    | 不可重复读 |          幻读           |
| :-----------------------------: | :--------: | :--------: | :---------------------: |
|  未提交读（Read Uncommitted）   |    可能    |    可能    |          可能           |
|   已提交读（Read Committed）    | ==不可能== |    可能    |          可能           |
| **可重复读（Repeatable Read）** | ==不可能== | ==不可能== | ==**对InnoDB 不可能**== |
|     串行化（Serializable）      | ==不可能== | ==不可能== |       ==不可能==        |

InnoDB 支持这四个隔离级别，InnoDB 默认使用的 RR 作为事务隔离级。隔离界别越高，事务的并发度就越低。唯一的区别就在于，InnoDB 在 RR 级别就解决了幻读的问题。**因此不需要使用串行化的隔离界别去解决所有的问题，既保证了数据的一致性，又支持较高的并发度。**



## MVCC为什么需要、怎么实现的、解决什么问题

MVCC
